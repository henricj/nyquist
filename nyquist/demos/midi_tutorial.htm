<html>
<head><meta name="GENERATOR" content="Microsoft FrontPage 3.0"><title>Midi Tutorial</title></head><body><h1>Midi Tutorial</h1><p>Nyquist can read and write midi files. Midi files are read into and written from aspecial XLisp data type called a <code>SEQ</code>, which is short for&quot;sequence&quot;. (This is not part of standard XLisp, but rather part of Nyquist.)Nyquist can examine the contents of a <code>SEQ</code> type, modify the <code>SEQ</code>by adding or deleting Midi notes and other messages. Finally, and perhaps mostimportantly, Nyquist can use the data in a <code>SEQ</code> type along with a soundbehavior to generate sound. In other words, Nyquist can become a Midi synthesizer.</p><h2>The <code>SEQ</code> Type</h2><p>To create a <code>SEQ</code> data object:</p><pre><strong>&gt; </strong>(setf my-seq (seq-create))<strong>#&lt;SEQ:0x7a6f60&gt;&gt; </strong>(type-of my-seq)<strong>SEQ&gt;</strong></pre><h2>Reading a Midi File</h2><p>Once you have a sequence, you can read Midi data into it from a file. You do this inthree steps. First, you open the file in binary mode (using <code>open-binary</code>, aNyquist extension to XLisp). Then you read from the file. Finally, you (normally) closethe file.</p><pre>(setf midi-file (open-binary &quot;demo.mid&quot;))(seq-read-smf my-seq midi-file)(close midi-file)</pre><h2>Writing a Midi File</h2><p>A sequence can be written to a file. First you open the file as a binary output file;then you write it; then you close it.</p><pre>(setf midi-file (open-binary &quot;copy.mid&quot; :direction :output))(seq-write-smf my-seq midi-file t)(close midi-file)</pre><p>The result will not be a bit-for-bit copy of the original Midi file because the <code>SEQ</code>representation is not a complete representation of the Midi data. For example, the Midifile can contain headers and meta-data that is not captured by Nyquist. Nevertheless, theresulting Midi file should sound the same if you play it with a sequencer or Midi fileplayer.</p><h2>Writing a Text Representation</h2><p>One very handy feature of the <code>SEQ</code> datatype is that it was originallydeveloped for a text-based representation of files called the Adagio Score Language, orjust &quot;Adagio.&quot; You can write an Adagio file from a sequence by opening a textfile and calling <code>seq-write</code>.</p><pre>(setf gio-file (open &quot;copy.gio&quot; :direction :output))(seq-write my-seq gio-file)(close gio-file)</pre><p>The basic format of the Adagio file is pretty intuitive, but you can find the fulldescription in the CMU Midi Toolkit manual or in a chapter of the Nyquist manual,including the online version in HTML.</p><h2>Reading an Adagio File</h2><p>Because Adagio is text, you can easily edit them or compose your own Adagio file. Youshould be aware that Adagio supports numerical parameters, where pitch and duration arejust numbers, <em>and symbolic parameter, </em>where a pitch might be <code>Bf4</code>(for B-flat above middle-C) and a duration might be <code>QT</code> (for a quarter notetriplet). Symbolic parameters are especially convenient for manual entry of data. Once youhave an Adagio file, you can create a sequence from it in Nyquist:</p><pre>(setf seq-2 (seq-create))(setf gio-file (open &quot;demo.gio&quot;))(seq-read seq-2 gio-file)(close gio-file)</pre><h2>Adding Notes to a <code>SEQ</code> Type</h2><p>Although not originally intended for this purpose, XLisp and Nyquist form a powerfullanguage for generating Midi files. These can then be played using a Midi synthesizer orusing Nyquist, as will be illustrated later.</p><p>To add notes to a sequence, you call <code>seq-insert-note</code> as illustrated inthis routine, called <code>midinote</code>. Since <code>seq-insert-note</code> requiresinteger parameters, with time in milliseconds, <code>midinote</code> performes someconversions and limiting to keep data in range:</p><font FACE="Courier New" SIZE="2"><p>(defun midinote (seq time dur voice pitch vel)<br>&nbsp; (setf time (round (* time 1000)))<br>&nbsp; (setf dur (round (* dur 1000)))<br>&nbsp; (setf pitch (round pitch))<br>&nbsp; (setf vel (round vel))<br>&nbsp; (seq-insert-note seq time 0 (1+ voice) pitch dur vel))</p></font><p>Now, let's add some notes to a sequence:</p><pre>(defun test ()  (setf *seq* (seq-create))  (midinote *seq* 0.0 1.0 1 c4 100)  (midinote *seq* 1.0 0.5 1 d4 100)  (midinote *seq* 2.0 0.8 1 a4 100)  (setf seqfile (open-binary &quot;test.mid&quot; :direction :output))  (seq-write-smf *seq* seqfile)  (close seqfile))</pre><h2>A Larger Example</h2><p>This example illustrates the creation of random note onset times using the Poissondistribution. One way to generate this distribution, as seen here, is to create uniformlydistributed random times, and then sort these. The function that creates times and thenquantizes them to 24ths of a beat is shown here. The <code>len</code> parameter is thenumber of times, and the <code>average-ioi</code> parameter is the averageinter-onset-interval, the average time interval between two adjacent times:</p><pre>;; create list of random times and sort it;; dur in ms.(defun poisson-gen (len average-ioi)  (let ((dur (* len average-ioi)) poisson-list)    (dotimes (i len)	     (push (* dur (random 10000) 0.0001)                    poisson-list))    (setf poisson-list (sort poisson-list #'&lt;))    (display &quot;initial list&quot; poisson-list)    ;; map list to 24ths:    (setf poisson-list          (quantize-times-to-24ths poisson-list)) ))</pre><p>We add a few functions to help express time in terms of beats: </p><pre>(defun set-tempo (tempo)  (setf qtr (/ 60.0 tempo))  (setf 8th (* qtr 0.5))  (setf half (* qtr 2))  (setf whole (* qtr 4))  (setf 16th (* qtr 0.25)))(if (not (boundp 'qtr)) (set-tempo 100))(defun quantize-times-to-24ths (list)  (mapcar #'quantize-time-to-24ths list))(defun quantize-time-to-24ths (time)  (* (/ qtr 24.0)     (round (* 24 (/ time qtr)))))</pre><p>Now, let's create Midi notes using Poisson-based onset times: </p><pre>(defun melody (seq onsets)  (dolist (onset onsets)    (midinote seq onset 16th 1 (+ 48 (random 24)) 100)))(defun poisson-melody ()  (setf *seq* (seq-create))  (melody *seq* (poisson-gen 50 8th)) ;; adds notes to *seq*  (setf seqfile (open-binary &quot;pois.mid&quot; :direction :output))  (seq-write-smf *seq* seqfile)  (close seqfile))</pre><p>After evaluating <code>(poisson-melody)</code>, you can play the file&quot;pois.mid&quot; to hear the result. The times are quantized to 24th notes at a tempoof 100, so you can even use a notation editor to display the result in common musicnotation.</p><h2>Synthesizing a Midi File</h2><p>To synthesize sound from a Midi file, use the <code>seq-midi</code> control construct.This behavior reads the data in the <code>seq</code> object and for each note, creates aninstance of the behavior you provide. You will need an instrument, so let's define asimple FM instrument to play the notes of the Midi data:</p><pre>(defun fm-note (p)  (mult (pwl 0.01 1 .5 1 1)        (fmosc p               (mult (step-to-hz p)                     (pwl 0.01 6 0.5 4 1)                     (osc p)))))</pre><p>Now let's use <code>fm-note</code> to play the previously defined <code>poisson-melody</code>,which was saved in the variable <code>*seq*</code>: </p><pre>(play (seq-midi *seq* (note (chan pitch vel) (a-note pitch))))</pre><p>The <code>seq-midi</code> construct automatically uses time transformations to placenotes at the proper time and to stretch them to the indicated duration. In addition, itsets the <code>chan</code>, <code>pitch</code>, and <code>vel</code> parameters accordingto the Midi data before invoking your behavior. In this simple example, we ignored <code>chan</code>and <code>vel</code>, but we used <code>pitch</code> to get the right pitch. You mightwrite a more complicated behavior that uses <code>chan</code> to select differentsynthesis algorithms according to the Midi channel. </p><p>The syntax for the <code>seq-midi</code> construct may be a little confusing. Thesymbol <code>note</code> appears to be a function call, but it is not. It is really thereto say that the following parameter list and behavior expression apply to Midi notes.There can be other terms for other Midi messages, e.g. </p><pre>(seq-midi my-seq   (note (chan pitch velocity) (my-note pitch velocity))   (ctrl (chan control value) (...))   (bend (chan value) (...))   (touch (chan value) (...))   (prgm (chan value) (setf (aref my-prgm chan) value))</pre><h2>Examining <code>SEQ</code> Data</h2><p>In the lib folder of the standard Nyquist installation, there is a file called <code>midishow.lsp</code>.If you load this, you can call some functions that help you examine <code>SEQ</code> data.Try the following (after running <code>poisson-melody</code> above).</p><pre>(load &quot;midishow&quot;)(midi-show *seq*)</pre><p>You will see a printout of the data inside the <code>SEQ</code> data object. UnlikeMidi, which stores note-on and note-off messages separately, the <code>SEQ</code>structure saves notes as a single message that includes a duration. This is translated toand from Midi format when you write and read Midi files.</p><p>You can also examine a Midi file by calling:</p><pre>(midi-show-file &quot;demo.mid&quot;)</pre><p>This function can take an optional second argument specifying an opened text file ifyou want to write the data to a file rather than standard (console) output:</p><pre>(midi-show-file &quot;demo.mid&quot; (open &quot;dump.txt&quot; :direction :output))(gc)</pre><p>What is going on here? I did not save the opened file, but rather passed it directly to<code>midi-show-file</code>. Therefore, I did not have a value to pass to the <code>close</code>function. However, I know that files are closed by the garbage collector when there are nomore references to them, so I simply called the garbage collector <code>(gc)</code> to runand close the file.</p><p><br><br></p></body></html>
