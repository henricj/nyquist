<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;
      charset=windows-1252">
    <title>Vinyl Scratch Tutorial</title>
    <style>body {max-width: 40em}</style>
  </head>
  <body>
    <h1>Vinyl Scratch Tutorial</h1>
    <p>This sound reminds me of the effect of dragging a needle across a
      vinyl record. The function is defined with SAL syntax, followed by
      Lisp syntax in a smaller font size.<br>
    </p>
    <pre>function ring(dur, pch, scl)<br>  begin<br>    with modstep1 = hz-to-step(step-to-hz(pch) * sqrt(2.0)),
         modstep2 = hz-to-step(step-to-hz(pch) * sqrt(11.0))
    return env(0.05, 0.1, 0.2, 1, 0.6, 0.24, 1) *
           fmosc(pch, pwl(0.07, 1800, 0.15, 1000, 0.4, 680, <br>                          0.8, 240, 1, 100, 1) * 
		      scl * osc(modstep1) * osc(modstep2)) ~ dur
  end<br><br><small><small>(defun ring (dur pch scl)
  (let ((modstep1 (hz-to-step (* (step-to-hz pch) (sqrt 2.0))))
        (modstep2 (hz-to-step (* (step-to-hz pch) (sqrt 11.0)))))
    (stretch dur 
      (mult 
        (env 0.05 0.1 0.2 1 0.6 0.24 1)
        (fmosc pch (mult 
	             (pwl 0.07 1800 0.15 1000 0.4 680 0.8 240 1 100 1) 
		     scl 
                     (osc modstep1)
                     (osc modstep2) ))) )))</small></small></pre><small><small>

</small></small><p>The following plays an example sound from this function:</p>

<pre>play ring(7.1, hz-to-step(1), 1.2)
<br><small><small>(play (ring 7.1 (hz-to-step 1) 1.2))</small></small></pre><small><small>

</small></small><p>Here is a brief description of how this function works: The sound is created by an FM
oscillator. The modulation comes from two sinusoids operating at low frequencies
multiplied together. The sinusoids are not harmonically related, so an irregular pulse is
generated by their product. This is scaled further by a piece-wise linear envelope that
adds more variation. To make the sinusoids inharmonically related, their frequencies are
scaled by the square root of 2 and the square root of 11. The variables <code>modstep1</code>
and <code>modstep2</code> are initialized to these computed frequencies.</p>

<p>The following example combines several instances of <code>ring</code> with different
parameters:</p>

<pre>play sim(0.15 *  ring(7.1, hz-to-step(1), 1.2)   @ 2.9,
	 0.175 * ring(5.1, hz-to-step(2), 1.414) @ 4.9,
	 0.2 *   ring(3.1, hz-to-step(4), 1.8)   @ 6.9)

<small><small>(play (sim (scale 0.15 (at 2.9 (ring 7.1 (hz-to-step 1) 1.2)))
	   (scale 0.175 (at 4.9 (ring 5.1 (hz-to-step 2) 1.414)))
	   (scale 0.2 (at 6.9 (ring 3.1 (hz-to-step 4) 1.8)))))
</small></small></pre><small><small>

</small></small><h2>Other Sounds Using Ring</h2>

<p>The same <code>ring</code> function can be used to achieve other sounds. Listen to
these examples:</p>

<pre>play sim(0.35  * ring(4, 1,  1) @ 1.5,
	 0.325 * ring(4, 4,  2) @ 4,
         0.3   * ring(4, 10, 4) @ 7.5)
</pre><pre><small><small>(play (sim 
        (scale 0.35 (at 1.5 (ring 4 1 1)))
	(scale 0.325 (at 4 (ring 4 4 2)))
	(scale 0.3 (at 7.5 (ring 4 10 4))) ))</small></small></pre>

<p>These instances use a higher pitch parameter than the previous ones.<br>
</p>

<h2>Another Related Sound</h2>

<p>The following creates a sound using FM and a wave table derived from a vocal sound.</p>

<pre>function vocrap(pch: 16, dur: 1)<br>  begin<br>  &nbsp; if ! boundp(quote(*voc-table1*)) then exec mk-voc1-table()
    return fmosc(pch, <br>                 pwl(0, 3, 0.1, -20, 0.2, 20, 0.3, 30, 0.4, -10, <br>                     0.5, 15, 0.6, 0, 0.8, -30, 1, 60, 1),<br>                &nbsp;*voc-table1*) ~ dur<br>  end <br></pre><pre><small><small>(defun vocrap (&amp;optional (pch 16) (dur 1))
  (if (not (boundp '*voc-table1*)) (mk-voc1-table))
  (fmosc pch (stretch dur (pwl 0 3 0.1 -20 0.2 20 0.3 30
                               0.4 -10 0.5 15 0.6 0
                               0.8 -30 1 60 1)) *voc-table1*))</small></small></pre><small><small>

</small></small><p>This function uses a special test to make sure that <code>*voc-table1*</code> is
initialized. If it is not, it would be an error to read or test it, but you can query to
find out if the variable is bound or unbound. (Global variables become bound when you
assign a value to them.) The <code>boundp</code> function takes an atom (note the use of
the&nbsp; <tt>quote</tt> (or in Lisp, the single quote prefix character) to denote a symbol, the name of the variable, rather then the variable's
value) and returns true if the variable is bound.</p>

<p>Here is the definition for <code>mk-voc1-table</code>. You might have to replace the
filename depending upon how your system is configured.:</p>

<pre>function mk-voc1-table()<br>  begin<br>   &nbsp;if ! boundp(quote(voc-snd1)) then
      set voc-snd1 = s-read("./test/voc1.snd")<br>    set *voc-table1* = list(voc-snd1, 16, T)
</pre><pre><small><small>(defun mk-voc1-table ()
    (if (not (boundp 'voc-snd1))
        (setf voc-snd1 (s-read "./test/voc1.snd")))
    (setf *voc-table1* (list voc-snd1 16 T)))</small></small></pre><small><small>

</small></small><p>The following shows one way to invoke <code>vocrap</code>: </p>

<pre>play seqrep(i, 4, vocrap())<br><br><small><small>(play (seqrep (i 4) (vocrap)))
</small></small></pre>





</body></html>